!function(e,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.core=s():e.core=s()}(self,(()=>(()=>{"use strict";var e={};return((e,s)=>{Object.defineProperty(s,"__esModule",{value:!0}),s.validateRule=s.processRules=s.processVerbose=s.processGroup=s.flattenKeys=s.processRuleOrGroup=s.processResult=s.verbosePlugin=s.isGroup=s.operators=void 0,s.operators=["eq","neq","gt","lt","gte","lte","has","nhas","in","nit"];const r=".";function t(e={}){const{all:s,any:r}=e;return!(!s&&!r)}function n(e={},n,a=[]){if(t(n))return u(e,n,a);const[l,i,p]=n;if(null==l||!i)throw new Error(`Invalid Rule\n${JSON.stringify(n,null,2)}`);const c={pass:!1},f=e&&e[l],d=typeof f,y=("object"==typeof p&&t(p),Array.isArray(p)),g={value:f,type:d,queryFields:null};if(l.indexOf(r)>0){const s=o(e)[l],r=typeof s;s&&(g.value=s,g.type=Array.isArray(s)?"array":r)}const b="bigint"===g.type||"number"===g.type?parseInt(p,10):p,R=g.value;if("has"===i||"nhas"===i){if(["number","bigint","symbol","undefined"].includes(typeof R))return{pass:!1};const e=R.includes(p);c.pass="nhas"===i?!e:e}return"in"!==i&&"nit"!==i||(y||["string","object"].includes(typeof p))&&(c.pass=p.includes(R)),"eq"===i&&(c.pass=R===b),"neq"===i&&(c.pass=R!==b),"gt"===i&&(c.pass=R>b),"gte"===i&&(c.pass=R>=b),"lt"===i&&(c.pass=R<b),"lte"===i&&(c.pass=R<=b),(0,s.processResult)({...c,rule:n,facts:e,plugins:a})}function o(e,s="",r="."){return Object.entries(e).reduce(((e,[t,n])=>"object"!=typeof n||Array.isArray(n)?{...e,[`${s}${t}`]:n}:{...e,...o(n,`${s}${t}${r}`)}),{})}function u(e={},r={},t=[]){const{all:o,any:u}=r,a=s=>n(e,s,t);if(o){const n=o.map(a),u=n.every((e=>e.pass));return(0,s.processResult)({pass:u,rule:r,facts:e,plugins:t,group:{all:n,pass:u}})}if(u){const n=u.map(a),o=n.some((e=>e.pass));return(0,s.processResult)({pass:o,rule:r,facts:e,plugins:t,group:{any:n,pass:o}})}throw new Error(`Invalid RuleGroup\n${JSON.stringify(r,null,2)}`)}s.isGroup=t,s.verbosePlugin=({pass:e,rule:s,group:r})=>({pass:e,rule:s,group:r}),s.processResult=({pass:e,facts:s,rule:r,group:t,plugins:n=[]})=>n.reduce(((n,o)=>({...n,...o({pass:e,facts:s,rule:r,group:t})||{}})),{pass:e}),s.processRuleOrGroup=n,s.flattenKeys=o,s.processGroup=u,s.processVerbose=(e={},r,t=[])=>u(e,r,[s.verbosePlugin,...t]),s.processRules=u,s.validateRule=function e(r={}){const t=!1;if(!r)return{isValid:t,message:"No Rule Group Found"};const{all:n,any:o}=r;return n||o?(r=>{if(0===r.length)return{isValid:t,message:"No Rule Group Found"};for(let n=0;n<r.length;n++){const o=r[n];if(o?.all||o?.any)return e(o);const u=o;if(!Array.isArray(u)||u.length<2)return{isValid:t,message:"No Rule Group Found"};const[a,l]=u;if(!a||!l)return{isValid:t,message:"Invalid Rule"};if(!s.operators.includes(l))return{isValid:t,message:"Invalid Operator"}}return{isValid:!0}})(n||o):{isValid:t,message:"No Quantifiers (all|any) Found"}}})(0,e),e})()));