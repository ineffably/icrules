!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.core=r():e.core=r()}(self,(()=>(()=>{"use strict";var e={};return((e,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.processRules=r.validateRule=r.processVerbose=r.verbosePlugin=r.processGroup=r.processRuleOrGroup=r.internalOperators=r.processResult=r.flattenKeys=r.isGroup=r.internalOperatorValues=void 0,r.internalOperatorValues=["eq","neq","gt","lt","gte","lte","has","nhas","in","nit"];const s=".";function t(e={}){const{all:r,any:s}=e;return!(!r&&!s)}function n(e,r="",s="."){return Object.entries(e).reduce(((e,[t,u])=>"object"!=typeof u||Array.isArray(u)?{...e,[`${r}${t}`]:u}:{...e,...n(u,`${r}${t}${s}`)}),{})}r.isGroup=t,r.flattenKeys=n,r.processResult=({pass:e,facts:r,rule:s,group:t,plugins:n=[]})=>n.reduce(((n,u)=>({...n,...u({pass:e,facts:r,rule:s,group:t})||{}})),{pass:e});const u=e=>({value:r,term:s})=>{if(Array.isArray(s)||["string","object"].includes(typeof s)){const t=s.includes(r);return"in"===e?t:!t}return!1},l=e=>({value:r,term:s})=>{if(["number","bigint","symbol","undefined"].includes(typeof r))return!1;const t=r.includes(s);return"has"===e?t:!t};function o(e={},u,l={}){const{plugins:o=[],operators:i={}}=l;if(t(u))return a(e,u,{plugins:o});const[p,c,f]=u;if(null==p||!c)throw new Error(`Invalid Rule\n${JSON.stringify(u,null,2)}`);const d={pass:!1},y=e?.[p],g=typeof y,v=("object"==typeof f&&t(f),{value:y,type:g,queryFields:null});if(p.indexOf(s)>0){const r=n(e)[p],s=typeof r;r&&(v.value=r,v.type=Array.isArray(r)?"array":s)}const m="bigint"===v.type||"number"===v.type?parseInt(f,10):f,b=v.value;return r.internalOperators[c]&&(d.pass=r.internalOperators[c]({value:b,term:m})),i[c]&&(d.pass=i[c]({value:b,term:m})),(0,r.processResult)({...d,rule:u,facts:e,plugins:o})}function a(e={},s={},t={}){const{all:n,any:u}=s,{plugins:l=[]}=t,a=r=>o(e,r,t);if(n){const t=n.map(a),u=t.every((e=>e.pass));return(0,r.processResult)({pass:u,rule:s,facts:e,plugins:l,group:{all:t,pass:u}})}if(u){const t=u.map(a),n=t.some((e=>e.pass));return(0,r.processResult)({pass:n,rule:s,facts:e,plugins:l,group:{any:t,pass:n}})}throw new Error(`Invalid RuleGroup\n${JSON.stringify(s,null,2)}`)}r.internalOperators={eq:({value:e,term:r})=>e===r,neq:({value:e,term:r})=>e!==r,gt:({value:e,term:r})=>e>r,gte:({value:e,term:r})=>e>=r,lt:({value:e,term:r})=>e<r,lte:({value:e,term:r})=>e<=r,in:u("in"),nit:u("nit"),has:l("has"),nhas:l("nhas")},r.processRuleOrGroup=o,r.processGroup=a,r.verbosePlugin=({pass:e,rule:r,group:s})=>({pass:e,rule:r,group:s}),r.processVerbose=(e={},s,t=[])=>a(e,s,{plugins:[r.verbosePlugin,...t]}),r.validateRule=function e(s={}){const t=!1;if(!s)return{isValid:t,message:"No Rule Group Found"};const{all:n,any:u}=s;return n||u?(s=>{if(0===s.length)return{isValid:t,message:"No Rule Group Found"};for(let n=0;n<s.length;n++){const u=s[n];if(u?.all||u?.any)return e(u);const l=u;if(!Array.isArray(l)||l.length<2)return{isValid:t,message:"No Rule Group Found"};const[o,a]=l;if(!o||!a)return{isValid:t,message:"Invalid Rule"};if(!r.internalOperatorValues.includes(a))return{isValid:t,message:"Invalid Operator"}}return{isValid:!0}})(n||u):{isValid:t,message:"No Quantifiers (all|any) Found"}},r.processRules=a,r.default=r.processRules})(0,e),e})()));